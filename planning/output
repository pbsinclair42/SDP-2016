CommsAPI.py:    """Kicks the ball `distance` cm"""
CommsAPI.py:    print("Kicking ball "+str(distance)+"cm")
CommsAPI.py:    """Attempts to grab the ball"""
CommsAPI.py:    print("Grabbing ball")
CommsAPI.py:    """Attempts to ungrab the ball"""
actions.py:from globalObjects import me, ally, enemies, robots, ball
actions.py:        iAmNearBall = me.distance(ball.predictedPosition(9)) < me.distance(ball)
actions.py:        if ball.moving is False:
actions.py:            # turnToDirection(me.bearing(ball))
actions.py:        # ballcoming towards us:
actions.py:        elif ball.moving and iAmNearBall:
actions.py:        # ball moving but not towards us
actions.py:        elif ball.moving:
actions.py:            interceptObject(ball)
actions.py:            # if another robot's still holding the ball, just wait
actions.py:            if ball.status != BallStatus.free:
actions.py:                # if the ball's been kicked, we hope to collect it
actions.py:                if nearEnough(ball.direction, ball.bearing(me)):
actions.py:                    if ball.distance(me) < ROBOT_WIDTH + GRAB_DISTANCE:
actions.py:    # Predict where the enemy will shoot the ball
constants.py:# the time taken from starting kicking to the ball moving (seconds)
constants.py:# the ideal distance from the edge of our robot that we should grab the ball from (centimeters)
constants.py:# the ideal distance from the edge of our robot that we should open our claws to then grab the ball from (centimeters)
constants.py:# the distance from the ball that a robot needs to be before we assume it's got it (centimeters)
constants.py:    # get ball colour
constants.py:        raise _ConfigError("Invalid ball colour")
moveables.py:    """An object in the game that can move (ie robot or ball)"""
globalObjects.py:ball = Ball(name="ball")
globalObjects.py:moveables = [me,ally,ball]+enemies
goals.py:        # work out where we expect to find the ball
goals.py:        # TODO: replace with interceptObject(ball)?
goals.py:        expectedBallPosition = ball.currentPoint
goals.py:        # work out where we expect to find the ball
goals.py:        # TODO: replace with interceptObject(ball)?
goals.py:        expectedBallPosition = ball.currentPoint
goals.py:    # work out how far to kick the ball
goals.py:    """Stop bad people from scoring and pass ball to ally"""
goals.py:        return me.bearing(ball)
goals.py:        """rotate to face oponent with ball"""
goals.py:        return me.bearing(ball)
goals.py:        """Get the Y coord of ball to try and defend the goal"""
goals.py:        ballY = ball.currentPoint.y
goals.py:        return Point(ourGoal.x,ballY)
helperClasses.py:    """An enum listing the five different states of the ball, namely not held or held by one of the four robots"""
robotAI.py:from globalObjects import me, ally, enemies, robots, ball
robotAI.py:    print api.world['ball_center']
robotAI.py:        ball.update(Point(api.world['ball_center'][0],api.world['ball_center'][1]))
robotAI.py:        print("no ball update")
robotAI.py:    # update who has the ball - workaround until vision can tell us
robotAI.py:        if ball.distance(enemies[0]) < BALL_OWNERSHIP_DISTANCE:
robotAI.py:           ball.status = BallStatus.enemyA
robotAI.py:        elif ball.distance(enemies[1]) < BALL_OWNERSHIP_DISTANCE:
robotAI.py:           ball.status = BallStatus.enemyB
robotAI.py:        elif ball.distance(ally)< BALL_OWNERSHIP_DISTANCE:
robotAI.py:           ball.status = BallStatus.ally
robotAI.py:        elif ball.distance(me)< BALL_OWNERSHIP_DISTANCE and me.grabbed:
robotAI.py:            ball.status = BallStatus.me
robotAI.py:        elif Point(api.world['ball_center'][0],api.world['ball_center'][1]) !=None:
robotAI.py:            ball.status = BallStatus.free
robotAI.py:            action = raw_input("1. Collect ball\n2. Shoot ball\n3. Pass ball\n4. Recieve ball\n5. Block pass\n6. Guard Goal\n7. Stop\n? ")
simulator.py:                print("oh no, the ball bounced off the robot!")
simulator.py:    # grab the ball
simulator.py:        '''Update the status of our robot and the ball based on our recent actions
simulator.py:            # if it'll keep kicking for this whole tick, the only potential change is that the ball starts moving
simulator.py:            # if it'll keep grabbing for this whole tick, the only potential change is that the ball stops moving
simulator.py:                # if the ball is close enough stop the ball and toggle 'holding ball' state
simulator.py:        ## move ball (v = u +at)
simulator.py:def simulatedStart(myPoint, allyPoint, enemyAPoint, enemyBPoint, myRot, allyRot, enemyARot, enemyBRot, ballPoint, ballStat):
simulator.py:    '''Reset the status of all robots and the ball'''
simulator.py:    # reset all robots/balls
simulator.py:    simulatedBall.update(ballPoint)
simulator.py:    simulatedBall.status = ballStat
visionAPI.py:    ball_color = BALL_COLOUR
visionAPI.py:    ball = BallTracker(ball_color)
visionAPI.py:    """Returns the position of the ball relative to the pitch, in cm"""
visionAPI.py:        # get the coordinates of the ball
visionAPI.py:        ball_center = ball.getBallCoordinates(frame)
visionAPI.py:        if ball_center == None:
visionAPI.py:        return Point(ball_center[0]*X_RATIO,ball_center[1]*Y_RATIO)
visionAPI.py:    """Returns which robot, if any, is holding the ball"""
visionAPI.py:        # TODO: work out the ball status and return it
strategy.py:    # if we are closest to ball
strategy.py:    ballNearerMeThanAlly = ball.distance(me) > ball.distance(ally)
strategy.py:    ballToEnemyDist = min(ball.distance(enemies[0]), ball.distance(enemies[1]))
strategy.py:    ballNotNearEnemy = ballToEnemyDist < 50
strategy.py:    heldByEnemyA = ball.status == BallStatus.enemyA
strategy.py:    heldByEnemyB = ball.status == BallStatus.enemyB
strategy.py:    if ballNearerMeThanAlly and ballNotNearEnemy:
strategy.py:    # If the enemy has the ball
strategy.py:        # if i'm closer to the ball than the ally
strategy.py:        if me.distance(ball) < ally.distance(ball):
strategy.py:    # if we have the ball
strategy.py:    elif ball.status == BallStatus.me:
Binary file robotAI.pyc matches
Binary file constants.pyc matches
Binary file globalObjects.pyc matches
Binary file moveables.pyc matches
Binary file helperClasses.pyc matches
Binary file actions.pyc matches
Binary file arduinoAPI.pyc matches
Binary file simulator.pyc matches
Binary file goals.pyc matches
Binary file visionAPI.pyc matches
Binary file CommsAPI.pyc matches
Binary file .strategy.py.swp matches
worldAPI.py:ballPosition = (Point(api.world['ball_center'][0],api.world['ball_center'][1]))
Binary file .ropeproject/globalnames matches
robotAI.py~:from globalObjects import me, ally, enemies, robots, ball
robotAI.py~:    print api.world['ball_center']
robotAI.py~:        ball.update(Point(api.world['ball_center'][0],api.world['ball_center'][1]))
robotAI.py~:        print("no ball update")
robotAI.py~:    # update who has the ball - workaround until vision can tell us
robotAI.py~:        if ball.distance(enemies[0]) < BALL_OWNERSHIP_DISTANCE:
robotAI.py~:           ball.status = BallStatus.enemyA
robotAI.py~:        elif ball.distance(enemies[1]) < BALL_OWNERSHIP_DISTANCE:
robotAI.py~:           ball.status = BallStatus.enemyB
robotAI.py~:        elif ball.distance(ally)< BALL_OWNERSHIP_DISTANCE:
robotAI.py~:           ball.status = BallStatus.ally
robotAI.py~:        elif ball.distance(me)< BALL_OWNERSHIP_DISTANCE and me.grabbed:
robotAI.py~:            ball.status = BallStatus.me
robotAI.py~:        elif Point(api.world['ball_center'][0],api.world['ball_center'][1]) !=None:
robotAI.py~:            ball.status = BallStatus.free
robotAI.py~:            action = raw_input("1. Collect ball\n2. Shoot ball\n3. Pass ball\n4. Recieve ball\n5. Block pass\n6. Guard Goal\n7. Stop\n? ")
